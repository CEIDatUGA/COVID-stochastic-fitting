---
title: "Debug R Effective - Eamon"
output: html_notebook
author: Eric Marty & Eamon Odea
---
  
```{r setup, include=FALSE, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(include=TRUE, echo=FALSE, warning=FALSE, message=FALSE, out.width = "100%")
library(here)
library(tidyverse)
```

```{r functions}
# This fuction takes the dates and the dataframe of parameters in natural units, 
# and returns a vector for detection probability (q).
# dates <- seq(min(dates),max(dates),1)
# t <- seq_along(dates)
get_q <- function(t, params) {
  
  # detection probability # check against pomp code
  q_min <- params$base_detect_frac
  q_max <- params$max_detect_frac
  q_n <- params$detect_rampup # Hill coefficient
  q_th <- params$t_half_detect 
  # as defined in states-model.rmd:
  q <- scales::rescale(
    t^q_n / (q_th^q_n + t^q_n), 
    from = c(0,1), 
    to = c(q_min, q_max)
  )
  # as defined in makepompmodel:
  # 1/(1+exp(max_detect_par)) * exp(log_detect_inc_rate)^t / (exp(log_detect_inc_rate)^exp(log_half_detect) + exp(log_detect_inc_rate)^t) + base_detect_frac
  # q <- 1/(1 + q_max) * q_n ^ t / (q_n ^ q_th + q_n ^ t) + q_min # does not jive with q caluclation above
  
  return(q)
}
# This fuction takes the dates and the dataframe of parameters in natural units, 
# and returns a vector for diagnosis rate (s).
get_s <- function(t, params) {
  
  # diagnosis rate 
  s_max <- params$max_diag_factor
  s_n <- params$diag_rampup # Hill coefficient
  s_th <- params$t_half_diag 
  # s <- scales::rescale(
  #   t^s_n / (s_th^s_n + t^s_n),
  #   from = c(0,1),
  #   to = c(s_min, s_max)
  #   )
  
  # as defined in makepompmodel:
  # 1 + exp(log_max_diag) * exp(log_diag_inc_rate)^t / ( exp(log_diag_inc_rate)^exp(log_half_diag) +   exp(log_diag_inc_rate)^t)
  s <- 1 + s_max * s_n^t / ( s_n ^ s_th + s_n ^ t )
  
  return(s)
}
  
# This fuction takes the dates, number of susceptibles, population, omega, 
# and the dataframe of parameters in natural units, and returns a vector for R effective.
# Transition times between classes are expected to be per class, and not per sub-compartment.
getReff <- function(S, N=1, omega, q, s, params) {
  
  # variables
  S <- S/N # susceptible fraction
  # constants
  a <- params$frac_asym
  h <- params$frac_hosp
  
  # relative transmissibility
  b_L <- params$frac_trans_e
  b_I_a <- params$frac_trans_a
  b_I_su <- 1
  b_I_sd <- 1
  b_C <- params$frac_trans_c
  b_H <- params$frac_trans_h
  
  # rates of movement between compartments
  # rates are per class, not per sub-compartment
  gamma_L <- 1/params$time_e
  gamma_I_a <- 1/params$time_a
  gamma_I_su <- 1/params$time_su
  gamma_I_sd <- 1/params$time_sd
  gamma_C <- 1/params$time_c
  gamma_H <- 1/params$time_h
  
  # number of compartments. 
  # Set to 1 if gammas refer to the class, set to 4 if gammas refer to subcompartments
  subcompartments <- 1 
  
  R_e <- S * omega * subcompartments * (
    b_L / gamma_L +  (1 - a) * (
      q * ( 
        b_I_sd / (s * gamma_I_sd) 
        + b_C * s / gamma_C 
        + h * b_H / gamma_H 
      )
      + (1 - q) * b_I_su / gamma_I_su
    ) 
    + a * b_I_a / gamma_I_a 
  )
  
  return(R_e)
}
```

```{r data}
all_files <- list.files(path = here::here("output/current/"), pattern = ".csv")
param_files <- list.files(path = here::here("output/current/"), pattern = "params-natural.rds")
state_summaries <- tibble()
state_parameters <- tibble()
state_logliks <- tibble()
statedf <-readRDS(here::here("output/current", "statedf.rds"))
statevec <- gsub(".csv","",all_files)
allstates_pop <- statedf %>% filter(state_full %in% statevec) %>% pull(total_pop) %>% sum()
for(i in 1:length(all_files)) {
  do_file <- all_files[i]
  location <- sub(".csv", "", do_file)
  state_metadata <- statedf %>% filter(state_full == sub(".csv", "", do_file))
  state_pop <- state_metadata %>% pull(total_pop)
  # state_initR0 <- state_metadata %>% pull(initR0)
  # state_beta_s <- (state_initR0*.1)
  
  # tmp state params
  tmpparamfile <- here::here("output/current", param_files[i])
  # tmpparams <- readRDS(tmpparamfile)
  # tmp_loglik <- data.frame(location = unique(tmp$location),
  #                       log_lik = tmpparams["LogLik", 2])
  # rnms <- row.names(tmpparams)
  # tmpparams <- tmpparams %>%
  #   mutate(parameter = rnms) %>%
  #   filter(is_fitted == "yes") %>%
  #   dplyr::select(-is_fitted) %>%
  #   gather("key", "value", -parameter) %>%
  #   filter(key == "X1") %>%
  #   dplyr::select(-key) %>%
  #   mutate(location = unique(tmp$location)) %>%
  #   dplyr::select(location, value, parameter)
  # 
  # state_parameters <- bind_rows(state_parameters, tmpparams)
  # state_logliks <- bind_rows(state_logliks, tmp_loglik)
  
  statepars <- readRDS(tmpparamfile) 
  statepars_fixed <- statepars %>% 
    rownames_to_column(var = "param") %>% 
    dplyr::filter(is_fitted == "no") %>% 
    select(param,X1) %>% 
    pivot_wider(values_from = X1, names_from = param) %>% 
    select(-c(MIF_ID, LogLik, LogLik_SE))
  statepars_fitted <- statepars %>% 
    rownames_to_column(var = "param") %>% 
    dplyr::filter(is_fitted == "yes") %>% 
    select(param,X1) %>% 
    pivot_wider(values_from = X1, names_from = param)
  
  statepars_allmle <- bind_cols(statepars_fixed,statepars_fitted)
  
  # results
  tmpfile <- here::here("output/current", do_file)
  tmp <- read.csv(tmpfile) %>% mutate(date = as.Date(date))
  firstcasedate <- tmp$date %>% min()
  tmp <- tmp %>%
    filter(sim_type == "status_quo" | is.na(sim_type),
           variable %in% c("daily_cases", "daily_deaths", "daily_all_infections", 
                           "actual_daily_cases", "actual_daily_deaths",
                           "mobility_trend", "latent_trend", "combined_trend",
                           "cumulative_all_infections", "cumulative_deaths")) %>%
    dplyr::select(location, sim_type, period, date, variable, mean_value) %>% 
    pivot_wider(names_from = variable, values_from = mean_value) %>%
    # mutate(beta_s = state_beta_s) %>% 
    # calculate prevalence
    mutate(prevalence = daily_all_infections / (state_pop-cumulative_deaths)) %>% 
    # calculate omega
    rename(omega = combined_trend) %>% 
    # calculate mean S
    mutate(susceptible_fraction = (state_pop - cumulative_all_infections) / (state_pop - cumulative_deaths)) %>% 
    # calculate q
    mutate(q = get_q(t = as.numeric(date-firstcasedate), params = statepars_allmle)) %>%
    # calculate s
    mutate(s = get_q(t = as.numeric(date-firstcasedate), params = statepars_allmle)) %>%
    # calculate mean R_e
    mutate(R_e = getReff(S = susceptible_fraction, N = 1, # whole population
                         omega = omega,
                         q = q,
                         s = s,
                         params = statepars_allmle)) %>%
    pivot_longer(cols = !c(location, sim_type, period, date), 
                 names_to = "variable", 
                 values_to = "mean_value",
                 values_drop_na = TRUE)
  state_summaries <- bind_rows(state_summaries, tmp)
}
# Key Dates
future <- state_summaries %>% filter(period == "Future") %>% pull(date) %>% range()
burnin <- c(state_summaries %>% pull(date) %>% min(), as.Date("2020-03-01"))
sample_period <- c(as.Date("2020-03-01"),as.Date("2020-12-31"))
```



```{r R_effective, fig.height=3, fig.width=7, eval = TRUE}
all_re <- state_summaries %>%
  filter(variable == "R_e") %>%
  dplyr::select(location, date, mean_value) %>%
  rename(R_e = mean_value) %>% 
  filter(date <= Sys.Date()) %>% 
  left_join(statedf, by=c("location" = "state_full")) %>% 
  mutate(relative_pop = total_pop / allstates_pop)
mean_re <- all_re %>% group_by(date) %>% summarise(R_e = mean(R_e))
weighted_mean_re <- all_re %>% group_by(date) %>% summarise(R_e = sum(R_e*relative_pop))
g_re <- ggplot(all_re, aes(x = date, y = R_e, color = location)) +
  geom_line(size = 0.5) +
  # ylab("Human movement\n(% of normal)") +
  scale_y_continuous(limits = c(0,5)) +
  scale_color_viridis_d(option = "D", direction = -1, alpha = .6, end = .75) +
  # theme_dark(base_line_size = 0.5) +
  geom_line(data = weighted_mean_re, alpha = .6, size = 2, color = 'red') +
  # geom_rect(aes(xmin=future[1], xmax=future[2], ymin=0, ymax=1)) +
  annotate("rect", xmin = future[1], xmax = future[2], ymin = 0, ymax = 5, alpha = .2) +
  geom_hline(yintercept = 1) +
  theme_minimal() +
  guides(color = FALSE)
p_re <- g_re %>% plotly::ggplotly() %>% 
  plotly::layout(showlegend = FALSE,
                 # margin = list(l = 150),
                 yaxis = list(title = "R_e")
                 )
p_re$x$data[[51]]$text <- gsub('red','Mean of all states', p_re$x$data[[51]]$text)
p_re
```


```{r}
readRDS(here::here("/output/debug", "Alabama.rds"))-> al
foo <- al$scenarios$sims %>% filter(rep_id == "1-1") %>% slice(1:237) %>% 
  filter(time <= 195) %>%
  mutate(Itotal = Ia1 + Ia2 + Ia3 + Ia4 + Isu1 + Isu2 + Isu3 + Isu4 + Isd1 + Isd2 + Isd3 + Isd4)
basis <- t(al$pomp_covar@table[c("seas_1", "seas_2", "seas_3", "seas_4", "seas_5", "seas_6", "seas_7", "seas_8", "seas_9"),]) 
spline_pars <- as.numeric(al$all_partable[1, c("b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9")])
trend00 <- as.numeric(basis %*% spline_pars)
basis %*% spline_pars
gamma1 <- exp(foo$trendO) / (1 + exp(foo$trendO))
gamma <- exp(trend00)/ (1 + exp(trend00))
rel_beta_change <- al$pomp_model@covar@table[1,]
delta <- rel_beta_change * gamma
delta <- ifelse(delta > 1, 1, delta)
beta <- exp(al$all_partable$log_beta_s[1]) * delta
## Check value of all fixed parameters for consistency with supplement
all(round(1 / (1 + exp(al$all_partable$trans_e)), 3) == 0.119)
all(round(1 / (1 + exp(al$all_partable$trans_a)), 3) == 0.500)
all(round(1 / (1 + exp(al$all_partable$trans_c)), 3) == 0.269)
all(round(1 / (1 + exp(al$all_partable$trans_h)), 7) == 4.54e-5)
all(round(exp(al$all_partable$log_max_diag), 1) == 1) # supplement says 2
all(round(exp(al$all_partable$log_diag_inc_rate), 2) == 1.1)
all(round(exp(al$all_partable$log_half_diag)) == 30)
all(round(al$all_partable$max_detect_par, 1) == 0.4)
all(round(exp(al$all_partable$log_detect_inc_rate), 2) == 1.1)
all(round(exp(al$all_partable$log_half_detect)) == 30)
all(round(exp(al$all_partable$base_detect_frac), 1) == 0.1)
all(round(1 / (1 + exp(al$all_partable$frac_asym)), 3) == 0.182)
all(round(1 / (1 + exp(al$all_partable$frac_hosp)), 3) == 0.119)
all(round(exp(al$all_partable$log_g_e)) == 1)
all(round(exp(al$all_partable$log_g_c)) == 1) ## 4 days when s=1, supplement says 3 days
all(round(exp(al$all_partable$log_g_h)) == 1) ## 4 days, supplement says 6 days
all(round(exp(al$all_partable$log_g_a)) == 1) ## 4 days, supplement says 3.5 days
all(round(exp(al$all_partable$log_g_sd)) == 1) ## 4 days when s = 1, supplement says 3 days 
all(round(exp(al$all_partable$log_g_su)) == 1) ## 4 days, supplement says 6 days
detect_frac <- function(t){
with(al$all_partable[1,], 1/(1+exp(max_detect_par)) * (t ^ exp(log_detect_inc_rate))  / ( (exp(log_half_detect) ^ exp(log_detect_inc_rate)) + (t ^ exp(log_detect_inc_rate))) + exp(base_detect_frac))
}
diag_rate <- function(t){
  with(al$all_partable[1,], 
       1 + exp(log_max_diag)  *  (t ^ exp(log_diag_inc_rate)) / ((exp(log_half_diag) ^ exp(log_diag_inc_rate))  + (t ^ exp(log_diag_inc_rate))))
}
{plot(foo$time, detect_frac(foo$time))
abline(v=30)
abline(h=.3)}
plot(foo$time, diag_rate(foo$time))
S <- foo$S
omega <- beta
b_L <- 0.5
gamma_L <- 0.25
a <- 0.182
q <- detect_frac(foo$time)
b_I_sd <- 1
b_I_su <- 1
s <- diag_rate(foo$time)
gamma_I_sd <- .25
gamma_C <- .25
gamma_H <- .25
gamma_I_su <- .25
gamma_I_a <- .25
b_I_a <- 0.5
b_C <- .269
b_H <- 4.54e-5
h <- 0.119
R_e <- S * omega * (
    b_L / gamma_L +  (1 - a) * (
      q * ( 
        b_I_sd / (s * gamma_I_sd) 
        + b_C * s / gamma_C 
        + h * b_H / gamma_H 
      )
      + (1 - q) * b_I_su / gamma_I_su
    ) 
    + a * b_I_a / gamma_I_a 
  )
{par(mfrow = c(2, 1))
plot(foo$time, R_e)
abline(h = 1)
plot(foo$time, foo$cases)
}
```


```{r}
setwd("work/local-run/weekly-forecast-simulations/2020-09-21/")
az <- readRDS("Arizona.rds")
foo2 <- az$scenarios$sims %>% filter(rep_id == "1-1") %>% slice(1:237) %>% 
  filter(time <= 195) %>%
  mutate(Itotal = Ia1 + Ia2 + Ia3 + Ia4 + Isu1 + Isu2 + Isu3 + Isu4 + Isd1 + Isd2 + Isd3 + Isd4)
basis2 <- t(az$pomp_covar@table[c("seas_1", "seas_2", "seas_3", "seas_4", "seas_5", "seas_6", "seas_7", "seas_8", "seas_9"),1:195]) 
spline_pars2 <- as.numeric(az$all_partable[1, c("b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9")])
trend002 <- as.numeric(basis2 %*% spline_pars2)
gamma2 <- exp(trend002)/ (1 + exp(trend002))
rel_beta_change2 <- az$pomp_model@covar@table[1,1:195]
delta2 <- rel_beta_change2 * gamma2
delta2 <- ifelse(delta2 > 1, 1, delta2)
beta2 <- exp(az$all_partable$log_beta_s[1]) * delta2
## Check value of all fixed parameters for consistency with supplement
all(round(1 / (1 + exp(az$all_partable$trans_e)), 3) == 0.119)
all(round(1 / (1 + exp(az$all_partable$trans_a)), 3) == 0.500)
all(round(1 / (1 + exp(az$all_partable$trans_c)), 3) == 0.269)
all(round(1 / (1 + exp(az$all_partable$trans_h)), 7) == 4.54e-5)
all(round(exp(az$all_partable$log_max_diag), 1) == 1) # supplement says 2
all(round(exp(az$all_partable$log_diag_inc_rate), 2) == 1.1)
all(round(exp(az$all_partable$log_half_diag)) == 30)
all(round(az$all_partable$max_detect_par, 1) == 0.4)
all(round(exp(az$all_partable$log_detect_inc_rate), 2) == 1.1)
all(round(exp(az$all_partable$log_half_detect)) == 30)
all(round(exp(az$all_partable$base_detect_frac), 1) == 0.1)
all(round(1 / (1 + exp(az$all_partable$frac_asym)), 3) == 0.182)
all(round(1 / (1 + exp(az$all_partable$frac_hosp)), 3) == 0.119)
all(round(exp(az$all_partable$log_g_e)) == 1)
all(round(exp(az$all_partable$log_g_c)) == 1) ## 4 days when s=1, supplement says 3 days
all(round(exp(az$all_partable$log_g_h)) == 1) ## 4 days, supplement says 6 days
all(round(exp(az$all_partable$log_g_a)) == 1) ## 4 days, supplement says 3.5 days
all(round(exp(az$all_partable$log_g_sd)) == 1) ## 4 days when s = 1, supplement says 3 days 
all(round(exp(az$all_partable$log_g_su)) == 1) ## 4 days, supplement says 6 days
detect_frac <- function(t){
with(az$all_partable[1,], 1/(1+exp(max_detect_par)) * (t ^ exp(log_detect_inc_rate))  / ( (exp(log_half_detect) ^ exp(log_detect_inc_rate)) + (t ^ exp(log_detect_inc_rate))) + exp(base_detect_frac))
}
diag_rate <- function(t){
  with(az$all_partable[1,], 
       1 + exp(log_max_diag)  *  (t ^ exp(log_diag_inc_rate)) / ((exp(log_half_diag) ^ exp(log_diag_inc_rate))  + (t ^ exp(log_diag_inc_rate))))
}
{plot(foo2$time, detect_frac(foo2$time))
abline(v=30)
abline(h=.3)}
plot(foo2$time, diag_rate(foo2$time))
S <- foo2$S
omega <- beta2
b_L <- 0.5
gamma_L <- 0.25
a <- 0.182
q <- detect_frac(foo2$time)
b_I_sd <- 1
b_I_su <- 1
s <- diag_rate(foo2$time)
gamma_I_sd <- .25
gamma_C <- .25
gamma_H <- .25
gamma_I_su <- .25
gamma_I_a <- .25
b_I_a <- 0.5
b_C <- .269
b_H <- 4.54e-5
h <- 0.119
R_e <- S * omega * (
    b_L / gamma_L +  (1 - a) * (
      q * ( 
        b_I_sd / (s * gamma_I_sd) 
        + b_C * s / gamma_C 
        + h * b_H / gamma_H 
      )
      + (1 - q) * b_I_su / gamma_I_su
    ) 
    + a * b_I_a / gamma_I_a 
  )
{par(mfrow = c(2, 1))
plot(foo2$time, R_e)
abline(h = 1)
plot(foo2$time, foo2$cases)
}
```